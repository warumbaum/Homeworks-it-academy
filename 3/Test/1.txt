1) Огрубляя, можно сказать, что уровни тестирования - это этапы тестирования продукта. В этом смысле уровни тестирования можно соотнести с жизненным циклом разработки продукта. Чтобы это показать наглядно, представим V-модель разработки. Слева сверху вниз идут этапы разработки продукта, справа снизу вверх - уровни тестирования. В результате модульное тестирование соотносится с этапом разработки архитектуры компонентов, интеграционное тестирование - разработки архитектуры системы, системное тестирование - разработки системных спецификаций, приемочное тестирование - разработки бизнес-требований. 
Используя метод аналогии, уровни тестирования можно показать на примере проверки свечи с подсвечником. Сначала мы тестируем подсвечник и свечу отдельно друг от друга (модульное тестирование), потом подсвечник и свечу вместе - насколько они подходят друг другу (интеграционное тестирование), следом тестируем весь собранный подсвечник целиком (системное тестирование), далее тестируем подсвечник со свечой в окружении, максимально приближенном месту использования подсвечника заказчиком, возможно, в помещении заказчика (приемочное тестирование). 
Модульное (компонентное) тестирование (unit testing) выполняется, как правило, силами разработчиков. Частый вид тестирования на этом уровне - статическое юнит-тестирование в автоматизированном виде, когда программный код продукта не запускается. 
Интеграционное тестирование (integration testing) выполняется, как правило, тестировщиками. Частый вид тестирования на этом уровне - тестирование взаимодействия - это функциональное тестирование, проверяющее способность приложения взаимодействовать с одним и более компонентами.
Системное тестирование (system testing) выполняется, как правило, тестировщиками. Частый вид тестирования на этом уровне - тестирование методом черного ящика. 
Приемочное тестирование (acceptance testing) выполняется, как правило, тестировщиками, но возможно привлечение заказчика, сторонних пользователей. Частый вид тестирования на этом уровне - функциональное тестирование в соответствии со стандартными сценариями использования продукта. 
2) Регрессионное тестирование - это вид тестирования, связанный с изменениями, происходящими в жизненном цикле ПО. Регрессионное тестирование проводится тогда, когда нужно убедиться что добавленные функции или исправленные баги не оказали влияния на текущую, уже существующую функциональность, работавшую и протестированную ранее. Особенности этого вида тестирования состоят в том, что перед выпуском очередной версии ПО пропускают через набор тестовых сценариев, подготовленных для предыдущей версии; новая версия ПО проверяется на наборе тестов, которые уже проводились с предыдущими ее версиями и не выявляли ошибок; отдельно выполняется проверка ранее обнаруженных, исправленных и проверенных ошибок. Эти особенности обусловили то, что часто регрессионное тестирование автоматизируется, и для него важно сохранять историю всех предыдущих тест-кейсов и баг-репортов. 
3) Юнит-тесты - это тесты отдельных юнитов (компонентов) программного кода; такие тесты проводятся без компиляции и сборки программы путем написания тестового кода, позволяющего автоматизировать процесс. Они проводятся, как правило, самими разработчиками без привлечения тестировщиков. Их преимущества в том, что они проводятся на ранней стадии разработки ПО, когда стоимость исправления ошибки не столь высока; они реализуются автоматизированным способом, за счет чего скорость непосредственного проведения теста высока; постоянное покрытие кода юнит-тестами позволяет поддерживать общую архитектуру разрабатываемого ПО, хорошо представлять себе эту архитектуру, документировать код и находить пути ее улучшения. В большинстве случаев нельзя ограничиться только юнит-тестами, поскольку они тестируют отдельные компоненты разрабатываемого ПО и не затрагивают область взаимодействия этих компонентов друг с другом, в том числе юзер-интерфейс, кроме того, данная технология бесполезна для проведения тестов на производительность; к тому же юнит-тестами нельзя покрыть весь код продукта; юнит-тесты не позволяют отловить все ошибки программы в силу невозможности трассировки всех возможных путей выполнения программы. Таким образом, юнит-тестирование играют большую роль в тестировании ПО, но эффективнее при использовании в сочетании с другими методиками тестирования.
4) Если мне предложат протестировать какой-то проект (программу, сайт), то, выбирая конкретные виды тестирования для этого проекта, я прежде всего попрошу ознакомиться с проектной документацией, спецификациями, затем попрошу провести сессию вопросов с заказчиком, проектировщиком или менеджером, на которой проясню для себя ключевые позиции спецификации, такие, как цели, задачи ПО, персонажи, для которых выполняется ПО, сегмент целевого рынка, оставшееся время на разработку, размер команды тестировщиков, ожидания заказчика и др. Из понимания общей цели и наличия финансово-временных ограничений я буду составлять тест-план и разверстку конкретных видов тестирования. 
5) Тестирование черного ящика предполагает проверки, основанные на работе исключительно с внешними интерфейсами тестируемого ПО. Тестирование белого ящика предполагает проверки, основанные на анализе внутренней структуры ПО. Если выразить это в общем плане, то при тестировании черного ящика мы концентрируемся на том, что программа делает, в то время как при тестировании белого ящика - на том, как она это делает. Примерами видов тестирования, которые невозможны при тестировании черного ящика, являются нагрузочное и стресс тестирования, а также все виды юнит-тестирования. 
